#!/bin/sh
# Tcl ignores the next line -*- tcl -*- \
exec wish "$0" -- "$@"

pack [scrollbar .commitsScroll -command {.commits yview}] -side right -fill y
pack [ttk::treeview .commits -yscrollcommand {.commitsScroll set}] -expand 1 -fill both

update

set logChannel [open "|git log -z --all --topo-order --pretty=format:%H:%P:%s"]
set logStrings [split [read $logChannel] "\0"]
close $logChannel

set ordered_commits {}
foreach lline $logStrings {
    if {[regexp -nocase {^([0-9a-f]+):([0-9a-f ]+):(.*)$} $lline _allLine hash mparents subject]} {
        lappend ordered_commits $hash
        set subjects($hash) $subject
        set parents($hash) [split $mparents " "]
    }
}

.commits insert {} end -id unmerged -text Unmerged
# hash => $num
array unset expected_priority
# hash => $hash|trunk
array unset expected_mergedTo
set expected_priority(de7514e386466e4fed750e9524e159a75ece56ec) 1
set expected_mergedTo(de7514e386466e4fed750e9524e159a75ece56ec) trunk
foreach h $ordered_commits {
    if {[info exists expected_priority($h)]} {
        set pr $expected_priority($h)
        set mt $expected_mergedTo($h)
    } else {
        set pr 0
        set mt unmerged
    }
    if {$mt eq "trunk"} {
        .commits insert {} end -id $h -text $subjects($h)
        set expected_priority([lindex $parents($h) 0]) [expr $pr + 1]
        set expected_mergedTo([lindex $parents($h) 0]) trunk
        foreach ph [lrange $parents($h) 1 end] {
            set expected_priority($ph) $pr
            set expected_mergedTo($ph) $h
        }
    } else {
        .commits insert $mt end -id $h -text $subjects($h)
        foreach ph $parents($h) {
            if {![info exists expected_priority($ph)] || [lindex $expected_priority($ph) 0] < $pr} {
                set expected_priority($ph) $pr
                set expected_mergedTo($ph) $mt
            }
        }
    }
}


